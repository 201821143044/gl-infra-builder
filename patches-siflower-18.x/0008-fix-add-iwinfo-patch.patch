From b48c134f4e3457ac3eba414f81166825152ddcb2 Mon Sep 17 00:00:00 2001
From: "GL.iNet-Xinfa.Deng" <xinfa.deng@gl-inet.com>
Date: Thu, 27 May 2021 15:53:17 +0800
Subject: [PATCH] fix: add iwinfo patch

Signed-off-by: GL.iNet-Xinfa.Deng <xinfa.deng@gl-inet.com>
---
 .../iwinfo/patches/000-add_rtwifi_support.patch    | 224 +++++++++++++++++++++
 .../001-add-htmodelist-for-scan-results.patch      | 203 +++++++++++++++++++
 .../iwinfo/patches/002-fix-station-mode-scan.patch |  27 +++
 3 files changed, 454 insertions(+)
 create mode 100644 openwrt-18.06/package/network/utils/iwinfo/patches/000-add_rtwifi_support.patch
 create mode 100755 openwrt-18.06/package/network/utils/iwinfo/patches/001-add-htmodelist-for-scan-results.patch
 create mode 100644 openwrt-18.06/package/network/utils/iwinfo/patches/002-fix-station-mode-scan.patch

diff --git a/openwrt-18.06/package/network/utils/iwinfo/patches/000-add_rtwifi_support.patch b/openwrt-18.06/package/network/utils/iwinfo/patches/000-add_rtwifi_support.patch
new file mode 100644
index 0000000..e061f7d
--- /dev/null
+++ b/openwrt-18.06/package/network/utils/iwinfo/patches/000-add_rtwifi_support.patch
@@ -0,0 +1,224 @@
+--- a/Makefile
++++ b/Makefile
+@@ -14,6 +14,10 @@ IWINFO_CLI         = iwinfo
+ IWINFO_CLI_LDFLAGS = $(LDFLAGS) -L. -liwinfo
+ IWINFO_CLI_OBJ     = iwinfo_cli.o
+ 
++ifneq ($(filter rt,$(IWINFO_BACKENDS)),)
++	IWINFO_CFLAGS  += -DUSE_RTWIFI
++	IWINFO_LIB_OBJ += iwinfo_rt_scan.o
++endif
+ 
+ ifneq ($(filter wl,$(IWINFO_BACKENDS)),)
+ 	IWINFO_CFLAGS  += -DUSE_WL
+--- a/iwinfo_cli.c
++++ b/iwinfo_cli.c
+@@ -111,7 +111,11 @@ static char * format_signal(int sig)
+ 	if (!sig)
+ 		snprintf(buf, sizeof(buf), "unknown");
+ 	else
++#ifdef USE_RTWIFI
++		snprintf(buf, sizeof(buf), "%d %", sig);
++#else
+ 		snprintf(buf, sizeof(buf), "%d dBm", sig);
++#endif
+ 
+ 	return buf;
+ }
+@@ -600,7 +604,11 @@ static void print_scanlist(const struct
+ 			IWINFO_OPMODE_NAMES[e->mode],
+ 			format_channel(e->channel));
+ 		printf("          Signal: %s  Quality: %s/%s\n",
++#ifdef USE_RTWIFI
++			format_signal(e->signal),
++#else
+ 			format_signal(e->signal - 0x100),
++#endif
+ 			format_quality(e->quality),
+ 			format_quality_max(e->quality_max));
+ 		printf("          Encryption: %s\n\n",
+--- /dev/null
++++ b/iwinfo_rt_scan.c
+@@ -0,0 +1,157 @@
++#include "iwinfo.h"
++#include "iwinfo_wext.h"
++
++struct survey_table
++{
++	char channel[4];
++	char ssid[33];
++	char len[4];
++	char bssid[20];
++	char security[23];
++	char *crypto;
++	char signal[9];
++};
++
++struct survey_table st[64];
++int survey_count = 0;
++
++#define RTPRIV_IOCTL_SET (SIOCIWFIRSTPRIV + 0x02)
++void iwpriv(const char *name, const char *key, const char *val)
++{
++	int socket_id;
++	struct iwreq wrq;
++	char data[64];
++	snprintf(data, 64, "%s=%s", key, val);
++	socket_id = socket(AF_INET, SOCK_DGRAM, 0);
++	strcpy(wrq.ifr_ifrn.ifrn_name, name);
++	wrq.u.data.length = strlen(data);
++	wrq.u.data.pointer = data;
++	wrq.u.data.flags = 0;
++	ioctl(socket_id, RTPRIV_IOCTL_SET, &wrq);
++	close(socket_id);
++}
++
++static void next_field(char **line, char *output, int n) {
++	char *l = *line;
++	int i;
++
++	memcpy(output, *line, n);
++	*line = &l[n];
++
++	for (i = n - 1; i > 0; i--) {
++		if (output[i] != ' ')
++			break;
++		output[i] = '\0';
++	}
++}
++
++#define RTPRIV_IOCTL_GSITESURVEY (SIOCIWFIRSTPRIV + 0x0D)
++void wifi_site_survey(const char *ifname, char* essid, int print)
++{
++	char *s = malloc(IW_SCAN_MAX_DATA);
++	int ret;
++	int socket_id;
++	struct iwreq wrq;
++	char *line, *start;
++	iwpriv(ifname, "SiteSurvey", (essid ? essid : ""));
++	sleep(5);
++	memset(s, 0x00, IW_SCAN_MAX_DATA);
++	strcpy(wrq.ifr_name, ifname);
++	wrq.u.data.length = IW_SCAN_MAX_DATA;
++	wrq.u.data.pointer = s;
++	wrq.u.data.flags = 0;
++	socket_id = socket(AF_INET, SOCK_DGRAM, 0);
++	ret = ioctl(socket_id, RTPRIV_IOCTL_GSITESURVEY, &wrq);
++	close(socket_id);
++	if(ret != 0)
++		goto out;
++	if(wrq.u.data.length < 1)
++		goto out;
++	/* ioctl result starts with a newline, for some reason */
++	start = s;
++	while (*start == '\n')
++		start++;
++	line = strtok((char *)start, "\n");
++	line = strtok(NULL, "\n");
++	survey_count = 0;
++	while(line && (survey_count < 64)) {
++		memset(&st[survey_count], 0, sizeof(st[survey_count]));
++
++		next_field(&line, st[survey_count].channel, sizeof(st->channel));
++		next_field(&line, st[survey_count].ssid, sizeof(st->ssid));
++		next_field(&line, st[survey_count].len, sizeof(st->len));
++		next_field(&line, st[survey_count].bssid, sizeof(st->bssid));
++		next_field(&line, st[survey_count].security, sizeof(st->security));
++		st[survey_count].crypto = strstr(st[survey_count].security, "/");
++		if (st[survey_count].crypto) {
++			*st[survey_count].crypto = '\0';
++			st[survey_count].crypto++;
++			if (print) printf("%s|%s|%s|%s\n",
++				st[survey_count].channel, st[survey_count].ssid, st[survey_count].bssid, st[survey_count].security);
++		}
++		next_field(&line, st[survey_count].signal, sizeof(st->signal));
++		line = strtok(NULL, "\n");
++
++		/* skip hidden ssid */
++		if (!strcmp(st[survey_count].len, "0")) {
++			continue;
++		}
++		survey_count++;
++	}
++	if (survey_count == 0 && !print)
++		printf("No results");
++out:
++	free(s);
++}
++
++/*struct survey_table
++{
++	char channel[4];
++	char ssid[33];
++	char bssid[20];
++	char security[23];
++	char *crypto;
++};
++*/
++
++int rt_get_scanlist(const char *ifname, char *buf, int *len)
++{
++        struct iwinfo_scanlist_entry *e = (struct iwinfo_scanlist_entry *) buf;
++	int i = 0;
++
++	survey_count = 0;
++
++	wifi_site_survey(ifname, NULL, 0);
++
++	for (i = 0; i < survey_count; i++) {
++		int j;
++		for (j = 0; j < 6; j++) {
++			e[i].mac[j] = (uint8_t) strtoul(&st[i].bssid[j * 3], NULL, 16);
++		}
++		strcpy(e[i].ssid, st[i].ssid);
++		e[i].channel = atoi(st[i].channel);
++		e[i].mode = IWINFO_OPMODE_MASTER;
++		e[i].signal = atoi(st[i].signal);
++		e[i].quality = atoi(st[i].signal);
++		e[i].quality_max = 100;
++		memset(&e[i].crypto, 0, sizeof(struct iwinfo_crypto_entry));
++		if (strstr(st[i].security, "WPA")) {
++			e[i].crypto.enabled = 1;
++			e[i].crypto.auth_suites |= IWINFO_KMGMT_PSK;
++		}
++		if (!st[i].crypto)
++			continue;
++		if (strstr(st[i].crypto, "TKIP"))
++			e[i].crypto.group_ciphers |= IWINFO_CIPHER_TKIP;
++		if (strstr(st[i].crypto, "AES"))
++			e[i].crypto.group_ciphers |= IWINFO_CIPHER_AESOCB;
++		if (strstr(st[i].security, "WPA2"))
++			e[i].crypto.wpa_version = 2;
++		else if (strstr(st[i].security, "WPA"))
++			e[i].crypto.wpa_version = 1;
++	}
++	*len = survey_count * sizeof(struct iwinfo_scanlist_entry);
++
++	return 0;
++}
++
+--- a/iwinfo_wext.c
++++ b/iwinfo_wext.c
+@@ -556,7 +556,11 @@ const struct iwinfo_ops wext_ops = {
+ 	.phyname          = wext_get_phyname,
+ 	.assoclist        = wext_get_assoclist,
+ 	.txpwrlist        = wext_get_txpwrlist,
++#ifdef USE_RTWIFI
++	.scanlist         = rt_get_scanlist,
++#else
+ 	.scanlist         = wext_get_scanlist,
++#endif
+ 	.freqlist         = wext_get_freqlist,
+ 	.countrylist      = wext_get_countrylist,
+ 	.close            = wext_close
+--- a/iwinfo_wext.h
++++ b/iwinfo_wext.h
+@@ -379,4 +379,8 @@ static const unsigned int standard_event
+ 
+ int wext_get_scanlist(const char *ifname, char *buf, int *len);
+ 
++#ifdef USE_RTWIFI
++int rt_get_scanlist(const char *ifname, char *buf, int *len);
++#endif
++
+ #endif
diff --git a/openwrt-18.06/package/network/utils/iwinfo/patches/001-add-htmodelist-for-scan-results.patch b/openwrt-18.06/package/network/utils/iwinfo/patches/001-add-htmodelist-for-scan-results.patch
new file mode 100755
index 0000000..b7a7c10
--- /dev/null
+++ b/openwrt-18.06/package/network/utils/iwinfo/patches/001-add-htmodelist-for-scan-results.patch
@@ -0,0 +1,203 @@
+From patchwork Mon Jul 16 07:48:54 2018
+Content-Type: text/plain; charset="utf-8"
+MIME-Version: 1.0
+Content-Transfer-Encoding: 7bit
+Subject: [OpenWrt-Devel,1/2] add htmodelist for scan results
+X-Patchwork-Submitter: Yury Shvedov <yshvedov@wimarksystems.com>
+X-Patchwork-Id: 944171
+X-Patchwork-Delegate: jow@openwrt.org
+Message-Id: <20180716074854.11321-1-yshvedov@wimarksystems.com>
+To: Jo-Philipp Wich <jo@mein.io>
+Cc: openwrt-devel@lists.openwrt.org
+Date: Mon, 16 Jul 2018 10:48:54 +0300
+From: Yury Shvedov <yshvedov@wimarksystems.com>
+List-Id: <openwrt-devel.lists.openwrt.org>
+
+The knowledge about HT and VHT modes could be useful for user experience.
+So grab it via nl80211 and make it available in both C and LUA APIs,
+and show htmodelist on CLI scan results.
+
+Signed-off-by: Yury Shvedov <yshvedov@wimarksystems.com>
+---
+ include/iwinfo.h |  1 +
+ iwinfo_cli.c     | 13 ++++++--
+ iwinfo_lua.c     | 14 ++++++++-
+ iwinfo_nl80211.c | 77 ++++++++++++++++++++++++++++++++++++++++++++++++
+ 4 files changed, 102 insertions(+), 3 deletions(-)
+
+diff --git a/include/iwinfo.h b/include/iwinfo.h
+index 929f697..b3f5470 100644
+--- a/include/iwinfo.h
++++ b/include/iwinfo.h
+@@ -154,6 +154,7 @@ struct iwinfo_scanlist_entry {
+ 	uint8_t signal;
+ 	uint8_t quality;
+ 	uint8_t quality_max;
++    uint16_t htmodelist;
+ 	struct iwinfo_crypto_entry crypto;
+ };
+ 
+diff --git a/iwinfo_cli.c b/iwinfo_cli.c
+index 49c9035..0429fbc 100644
+--- a/iwinfo_cli.c
++++ b/iwinfo_cli.c
+@@ -572,7 +572,7 @@ static void print_info(const struct iwinfo_ops *iw, const char *ifname)
+ 
+ static void print_scanlist(const struct iwinfo_ops *iw, const char *ifname)
+ {
+-	int i, x, len;
++	int i, h, x, len;
+ 	char buf[IWINFO_BUFSIZE];
+ 	struct iwinfo_scanlist_entry *e;
+ 
+@@ -603,8 +603,17 @@ static void print_scanlist(const struct iwinfo_ops *iw, const char *ifname)
+ 			format_signal(e->signal - 0x100),
+ 			format_quality(e->quality),
+ 			format_quality_max(e->quality_max));
+-		printf("          Encryption: %s\n\n",
++		printf("          Encryption: %s\n",
+ 			format_encryption(&e->crypto));
++		if (e->htmodelist)
++		{
++			printf("          HT Capabilities: ");
++			for (h = 0; h < ARRAY_SIZE(IWINFO_HTMODE_NAMES); h++)
++				if (e->htmodelist & (1 << h))
++					printf("%s ", IWINFO_HTMODE_NAMES[h]);
++			printf("\n");
++		}
++		printf("\n");
+ 	}
+ }
+ 
+diff --git a/iwinfo_lua.c b/iwinfo_lua.c
+index eebab8e..303fd08 100644
+--- a/iwinfo_lua.c
++++ b/iwinfo_lua.c
+@@ -378,7 +378,7 @@ static int iwinfo_L_txpwrlist(lua_State *L, int (*func)(const char *, char *, in
+ /* Wrapper for scan list */
+ static int iwinfo_L_scanlist(lua_State *L, int (*func)(const char *, char *, int *))
+ {
+-	int i, x, len = 0;
++	int i, x, h, len = 0;
+ 	char rv[IWINFO_BUFSIZE];
+ 	char macstr[18];
+ 	const char *ifname = luaL_checkstring(L, 1);
+@@ -432,6 +432,18 @@ static int iwinfo_L_scanlist(lua_State *L, int (*func)(const char *, char *, int
+ 			iwinfo_L_cryptotable(L, &e->crypto);
+ 			lua_setfield(L, -2, "encryption");
+ 
++			/* HT Modes */
++			if (e->htmodelist)
++			{
++				lua_newtable(L);
++				for (h = 0; h < ARRAY_SIZE(IWINFO_HTMODE_NAMES); h++)
++				{
++					lua_pushboolean(L, e->htmodelist & (1 << h));
++					lua_setfield(L, -2, IWINFO_HTMODE_NAMES[h]);
++				}
++                lua_setfield(L, -2, "htmodelist");
++			}
++
+ 			lua_rawseti(L, -2, x);
+ 		}
+ 	}
+diff --git a/iwinfo_nl80211.c b/iwinfo_nl80211.c
+index ecd2d6a..542ac7d 100644
+--- a/iwinfo_nl80211.c
++++ b/iwinfo_nl80211.c
+@@ -1980,6 +1980,71 @@ struct nl80211_scanlist {
+ 	int len;
+ };
+ 
++static void nl80211_parse_ht_capa(struct iwinfo_scanlist_entry *e,
++								  unsigned char *ie,
++								  int len)
++{
++	int capa;
++	if (len < 2)
++		return;
++	e->htmodelist |= IWINFO_HTMODE_HT20;
++	capa = ie[0] | (ie[8] << 8);
++	if (capa & (1 << 1))
++	{
++		e->htmodelist |= IWINFO_HTMODE_HT40;
++		if (e->htmodelist & IWINFO_HTMODE_VHT20)
++			e->htmodelist |= IWINFO_HTMODE_VHT40;
++	}
++}
++static void nl80211_parse_vht_capa(struct iwinfo_scanlist_entry *e,
++								   unsigned char *ie,
++								   int len)
++{
++	int capa;
++	if (len < 4)
++		return;
++	capa = ie[0] | (ie[1] << 8) | (ie[2] << 16) | (ie[3] << 24);
++
++	e->htmodelist |= IWINFO_HTMODE_VHT20;
++	if (e->htmodelist & IWINFO_HTMODE_HT40)
++		e->htmodelist |= IWINFO_HTMODE_VHT40;
++
++	switch ((capa >> 2) & 3) {
++	/*case 0: neither 160 nor 80+80 */
++	case 1:
++		e->htmodelist |= IWINFO_HTMODE_VHT160;
++		break;
++	case 2:
++		e->htmodelist |= IWINFO_HTMODE_VHT80_80;
++		break;
++	}
++}
++static void nl80211_parse_vht_oper(struct iwinfo_scanlist_entry *e,
++								   unsigned char *ie,
++								   int len)
++{
++	int chanwidth;
++	if (len < 1)
++		return;
++	chanwidth = ie[0];
++
++	e->htmodelist |= IWINFO_HTMODE_VHT20;
++	if (e->htmodelist & IWINFO_HTMODE_HT40)
++		e->htmodelist |= IWINFO_HTMODE_VHT40;
++
++	switch (chanwidth) {
++	/*case 0: 20 or 40 MHz */
++	case 1:
++		e->htmodelist |= IWINFO_HTMODE_VHT80;
++		break;
++	case 2:
++		e->htmodelist |= IWINFO_HTMODE_VHT160;
++		break;
++	case 3:
++		e->htmodelist |= IWINFO_HTMODE_VHT80_80;
++		break;
++	}
++}
+ 
+ static void nl80211_get_scanlist_ie(struct nlattr **bss,
+                                     struct iwinfo_scanlist_entry *e)
+@@ -1999,11 +2064,23 @@ static void nl80211_get_scanlist_ie(struct nlattr **bss,
+ 			e->ssid[len] = 0;
+ 			break;
+ 
++		case 45: /* HT Capabilities */
++			nl80211_parse_ht_capa(e, ie + 2, ie[1]);
++			break;
++
+ 		case 48: /* RSN */
+ 			iwinfo_parse_rsn(&e->crypto, ie + 2, ie[1],
+ 			                 IWINFO_CIPHER_CCMP, IWINFO_KMGMT_8021x);
+ 			break;
+ 
++		case 191: /* VHT Capabilities */
++			nl80211_parse_vht_capa(e, ie + 2, ie[1]);
++			break;
++
++		case 192: /* VHT Operation */
++			nl80211_parse_vht_oper(e, ie + 2, ie[1]);
++			break;
++
+ 		case 221: /* Vendor */
+ 			if (ie[1] >= 4 && !memcmp(ie + 2, ms_oui, 3) && ie[5] == 1)
+ 				iwinfo_parse_rsn(&e->crypto, ie + 6, ie[1] - 4,
diff --git a/openwrt-18.06/package/network/utils/iwinfo/patches/002-fix-station-mode-scan.patch b/openwrt-18.06/package/network/utils/iwinfo/patches/002-fix-station-mode-scan.patch
new file mode 100644
index 0000000..1374a74
--- /dev/null
+++ b/openwrt-18.06/package/network/utils/iwinfo/patches/002-fix-station-mode-scan.patch
@@ -0,0 +1,27 @@
+--- a/iwinfo_nl80211.c
++++ b/iwinfo_nl80211.c
+@@ -2535,10 +2535,10 @@ static int nl80211_get_scanlist(const ch
+ 	}
+ 
+ 	/* WPA supplicant */
+-	if (!nl80211_get_scanlist_wpactl(ifname, buf, len))
++	/*if (!nl80211_get_scanlist_wpactl(ifname, buf, len))
+ 	{
+ 		return 0;
+-	}
++	}*/
+ 
+ 	/* station / ad-hoc / monitor scan */
+ 	else if (!nl80211_get_mode(ifname, &mode) &&
+--- a/iwinfo_cli.c
++++ b/iwinfo_cli.c
+@@ -621,6 +621,9 @@ static void print_scanlist(const struct
+ 					printf("%s ", IWINFO_HTMODE_NAMES[h]);
+ 			printf("\n");
+ 		}
++		else{
++			printf("          HT Capabilities: UNKNOW \n");
++		}
+ 		printf("\n");
+ 	}
+ }
-- 
2.7.4

