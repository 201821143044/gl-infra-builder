From 73671e18eda8b4ad8db0c42341c1318c18e2fee6 Mon Sep 17 00:00:00 2001
From: Jianhui Zhao <jianhui.zhao@gl-inet.com>
Date: Sun, 26 Sep 2021 14:37:26 +0800
Subject: [PATCH] target/ramips: add et6326 led driver for GL-MT1300

Signed-off-by: Jianhui Zhao <jianhui.zhao@gl-inet.com>
---
 package/kernel/leds-et6326/Makefile          |  40 ++
 package/kernel/leds-et6326/src/Makefile      |   1 +
 package/kernel/leds-et6326/src/leds-et6326.c | 501 +++++++++++++++++++
 target/linux/ramips/dts/GL-MT1300.dts        |  45 +-
 target/linux/ramips/image/mt7621.mk          |   2 +-
 5 files changed, 571 insertions(+), 18 deletions(-)
 create mode 100644 package/kernel/leds-et6326/Makefile
 create mode 100644 package/kernel/leds-et6326/src/Makefile
 create mode 100644 package/kernel/leds-et6326/src/leds-et6326.c

diff --git a/package/kernel/leds-et6326/Makefile b/package/kernel/leds-et6326/Makefile
new file mode 100644
index 0000000000..df3ca18462
--- /dev/null
+++ b/package/kernel/leds-et6326/Makefile
@@ -0,0 +1,40 @@
+#
+#
+# This is free software, licensed under the GNU General Public License v2.
+# See /LICENSE for more information.
+#
+
+include $(TOPDIR)/rules.mk
+include $(INCLUDE_DIR)/kernel.mk
+
+PKG_NAME:=leds-et6326
+PKG_RELEASE:=1
+
+PKG_LICENSE:=GPL-2.0
+
+include $(INCLUDE_DIR)/package.mk
+
+define KernelPackage/leds-et6326
+  SUBMENU:=LED modules
+  TITLE:= ET6326 LED support
+  DEPENDS:=+kmod-i2c-core
+  FILES:=$(PKG_BUILD_DIR)/leds-et6326.ko
+  AUTOLOAD:=$(call AutoLoad,41,leds-et6326,1)
+  KCONFIG:=CONFIG_LEDS_CLASS
+endef
+
+define KernelPackage/leds-et6326/description
+  LED driver for ET6326 RGB LED.
+endef
+
+MAKE_OPTS:= \
+	$(KERNEL_MAKE_FLAGS) \
+	SUBDIRS="$(PKG_BUILD_DIR)"
+
+define Build/Compile
+	 $(MAKE) -C "$(LINUX_DIR)" \
+		$(MAKE_OPTS) \
+		modules
+endef
+
+$(eval $(call KernelPackage,leds-et6326))
diff --git a/package/kernel/leds-et6326/src/Makefile b/package/kernel/leds-et6326/src/Makefile
new file mode 100644
index 0000000000..4c707365e7
--- /dev/null
+++ b/package/kernel/leds-et6326/src/Makefile
@@ -0,0 +1 @@
+obj-m += leds-et6326.o
diff --git a/package/kernel/leds-et6326/src/leds-et6326.c b/package/kernel/leds-et6326/src/leds-et6326.c
new file mode 100644
index 0000000000..1326e20994
--- /dev/null
+++ b/package/kernel/leds-et6326/src/leds-et6326.c
@@ -0,0 +1,501 @@
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/leds.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+
+#define ET6326_MAX_LED_NUM			3
+
+#define ET6326_REG_STATUS			0x00
+#define ET6326_REG_FLASH_PERIOD		0x01
+#define ET6326_REG_FLASH_TON1		0x02
+#define ET6326_REG_FLASH_TON2		0x03
+#define ET6326_REG_LED_WORK_MODE	0x04
+#define ET6326_REG_RAMP_RATE		0x05
+#define ET6326_REG_LED1_IOUT		0x06
+#define ET6326_REG_LED2_IOUT		0x07
+#define ET6326_REG_LED3_IOUT		0x08
+
+#define ET6326_MAX_PERIOD			16380 	/* ms */
+
+struct et6326_leds_priv;
+
+enum {
+	MODE_ALWAYS_OFF,
+	MODE_ALWAYS_ON,
+	MODE_THREAD
+};
+
+struct et6326_led {
+	struct et6326_leds_priv *priv;
+	struct led_classdev cdev;
+	int	mode;
+	u8 mode_mask;
+	u8 on_shift;
+	u8 blink_shift;
+	u8 reg_iout;
+	char name[0];
+};
+
+struct et6326_leds_priv {
+	struct i2c_client *client;
+	struct et6326_led *leds[ET6326_MAX_LED_NUM];
+};
+
+static int et6326_write_byte(struct i2c_client *client, u8 reg, u8 val)
+{
+	uint8_t buf[2] = { reg, val };
+	struct i2c_msg msg = {
+		.addr = client->addr,
+		.len = 2,
+		.buf = buf
+	};
+	int ret;
+
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: reg 0x%x, val 0x%x, err %d\n",
+						__func__, reg, val, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int et6326_read_byte(struct i2c_client *client, u8 reg)
+{
+	uint8_t buf[] = {reg};
+	int ret;
+
+	struct i2c_msg msgs[] = {
+		{
+			.addr = client->addr,
+			.flags = I2C_M_REV_DIR_ADDR,
+			.len = 1,
+			.buf = buf
+		}, {
+			.addr = client->addr,
+			.flags = I2C_M_RD | I2C_M_NOSTART,
+			.len = 1,
+			.buf = buf
+		}
+	};
+
+	ret = i2c_transfer(client->adapter, msgs, 2);
+	if (ret < 0) {
+		dev_err(&client->dev, "%s: reg 0x%x, err %d\n",
+						__func__, reg, ret);
+		return ret;
+	}
+
+	return buf[0];
+}
+
+static unsigned long et6326_set_period(struct et6326_leds_priv *priv, unsigned long period)
+{
+	int val = period / 128 - 1;
+
+	if (val < 0)
+		val = 0;
+
+	if (val > 127)
+		val = 127;
+
+	if (val != et6326_read_byte(priv->client, ET6326_REG_FLASH_PERIOD))
+		et6326_write_byte(priv->client, ET6326_REG_FLASH_PERIOD, val);
+
+	return (val + 1) * 128;
+}
+
+static void et6326_set_work_mode(struct et6326_led *led, int mode)
+{
+	struct et6326_leds_priv *priv = led->priv;
+	u8 val = et6326_read_byte(priv->client, ET6326_REG_LED_WORK_MODE);
+
+	val &= ~led->mode_mask;
+
+	if (mode == MODE_ALWAYS_ON)
+		val |= (1 << led->on_shift);
+	else if (mode == MODE_THREAD)
+		val |= 1 << led->blink_shift;
+
+	if (val == et6326_read_byte(priv->client, ET6326_REG_LED_WORK_MODE))
+		return;
+
+	led->mode = mode;
+	et6326_write_byte(priv->client, ET6326_REG_LED_WORK_MODE, val);
+}
+
+static void et6326_set_ton1_percentage(struct et6326_leds_priv *priv, u8 val)
+{
+	if (val > 100)
+		val = 100;
+
+	val = 255 * val / 100;
+
+	if (val == et6326_read_byte(priv->client, ET6326_REG_FLASH_TON1))
+		return;
+
+	et6326_write_byte(priv->client, ET6326_REG_FLASH_TON1, val);
+}
+
+static unsigned long et6326_set_ramp(struct et6326_leds_priv *priv, unsigned long val)
+{
+	u8 scaling = 1;
+	u8 reg = 0;
+
+	if (val >= 4096) {
+		if (val > 7680)
+			val = 7680;
+		scaling = 4;
+	} else if (val >= 2048) {
+		scaling = 2;
+	}
+
+	reg = val / 128 / scaling;
+	val = reg * 128 * scaling;
+
+	if (val == 0)
+		val = 2;
+
+	reg |= reg << 4;
+
+	if (reg != et6326_read_byte(priv->client, ET6326_REG_RAMP_RATE))
+		et6326_write_byte(priv->client, ET6326_REG_RAMP_RATE, reg);
+
+	reg = et6326_read_byte(priv->client, ET6326_REG_STATUS) & ~(0x3 << 5);
+	switch (scaling) {
+	case 2:
+		reg |= 1 << 5;
+		break;
+	case 4:
+		reg |= 1 << 6;
+		break;
+	case 8:
+		reg |= 3 << 5;
+		break;
+	default:
+		break;
+	}
+
+	if (reg != et6326_read_byte(priv->client, ET6326_REG_STATUS))
+		et6326_write_byte(priv->client, ET6326_REG_STATUS, reg);
+
+	return val;
+}
+
+static int et6326_set_brightness(struct led_classdev *led_cdev,
+	enum led_brightness value)
+{
+	struct et6326_led *led = container_of(led_cdev, struct et6326_led, cdev);
+	struct et6326_leds_priv *priv = led->priv;
+
+	if (value == LED_OFF)
+		et6326_set_work_mode(led, MODE_ALWAYS_OFF);
+	else if (led->mode == MODE_ALWAYS_OFF)
+		et6326_set_work_mode(led, MODE_ALWAYS_ON);
+	
+	et6326_write_byte(priv->client, led->reg_iout, value);
+
+	return 0;
+}
+
+static void et6326_set_gradient(struct led_classdev *led_cdev, bool on)
+{
+	struct et6326_led *led = container_of(led_cdev, struct et6326_led, cdev);
+	struct et6326_leds_priv *priv = led->priv;
+	u8 reg_period = et6326_read_byte(priv->client, ET6326_REG_FLASH_PERIOD);
+	unsigned long t = 0;
+
+	if (on)
+		t = (reg_period + 1) * 128;
+
+	et6326_set_ramp(priv, t);
+}
+
+static int et6326_set_blink(struct led_classdev *led_cdev,
+		unsigned long *delay_on,
+		unsigned long *delay_off)
+{
+	struct et6326_led *led = container_of(led_cdev, struct et6326_led, cdev);
+	struct et6326_leds_priv *priv = led->priv;
+	unsigned long period;
+
+	/* blink with 1 Hz as default if nothing specified */
+	if (!*delay_on && !*delay_off)
+		*delay_on = *delay_off = 500;
+
+	if (*delay_on > ET6326_MAX_PERIOD)
+		*delay_on = ET6326_MAX_PERIOD;
+
+	if (*delay_off > ET6326_MAX_PERIOD - *delay_on)
+		*delay_off = ET6326_MAX_PERIOD - *delay_on;
+
+	period = *delay_on + *delay_off;
+
+	et6326_set_period(priv, period);
+	et6326_set_ton1_percentage(priv, *delay_on * 100 / period);
+
+	et6326_set_work_mode(led, MODE_THREAD);
+	et6326_write_byte(priv->client, led->reg_iout, 0xff);
+
+	if (led_cdev->gradiented)
+		et6326_set_gradient(led_cdev, true);
+
+	return 0;
+}
+
+static int create_led(struct et6326_leds_priv *priv, u32 channel, const char *name)
+{
+	struct device *dev = &priv->client->dev;
+	struct et6326_led *led;
+	bool auto_name = true;
+	int ret;
+
+	if (name && name[0])
+		auto_name = false;
+	else
+		name = "et6326-x";
+
+	led = devm_kzalloc(dev, sizeof(struct et6326_led) + strlen(name) + 1, GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	if (auto_name)
+		snprintf(led->name, strlen(name) + 1, "et6326-%u", channel);
+	else
+		strcpy(led->name, name);
+
+	led->priv = priv;
+	led->cdev.name = led->name;
+	led->cdev.brightness = LED_OFF;
+	led->cdev.brightness_set_blocking = et6326_set_brightness;
+	led->cdev.blink_set = et6326_set_blink;
+	led->cdev.gradient_set = et6326_set_gradient;
+
+	switch (channel) {
+	case 0:
+		led->mode_mask = 0x03;
+		led->on_shift = 0;
+		led->blink_shift = 1;
+		break;
+	case 1:
+		led->mode_mask = (0x03 << 2) | (1 << 6);
+		led->on_shift = 2;
+		led->blink_shift = 3;
+		break;
+	case 2:
+		led->mode_mask = (0x03 << 4) | (1 << 7);
+		led->on_shift = 4;
+		led->blink_shift = 5;
+		break;
+	default:
+		return -EINVAL;
+	}
+	
+	led->reg_iout = ET6326_REG_LED1_IOUT + channel;
+
+	ret = led_classdev_register(dev, &led->cdev);
+	if (ret < 0) {
+		dev_err(dev, "couldn't register LED '%s' on channel %d\n", led->name, channel);
+		return ret;
+	}
+
+	dev_info(&priv->client->dev, "Created a LED '%s' at channel %d\n", led->name, channel);
+
+	priv->leds[channel] = led;
+
+	return 0;
+}
+
+static int remove_led(struct et6326_leds_priv *priv, u32 channel)
+{
+	struct et6326_led *led;
+
+	if (channel > ET6326_MAX_LED_NUM - 1 || channel < 0)
+		return -EINVAL;
+
+	led = priv->leds[channel];
+
+	if (!led)
+		return -ENODEV;
+
+	et6326_set_brightness(&led->cdev, LED_OFF);
+
+	led_classdev_unregister(&led->cdev);
+
+	dev_info(&priv->client->dev, "LED '%s' was removed\n", led->name);
+
+	priv->leds[channel] = NULL;
+
+	return 0;
+}
+
+static ssize_t et6326_export_store(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t len)
+{
+	struct et6326_leds_priv *priv = i2c_get_clientdata(to_i2c_client(dev));
+	u32 channel;
+	int ret;
+	char *name;
+
+	name = strchr(buf, ' ');
+	if (name) {
+		char *ln;
+
+		*name++ = '\0';
+
+		ln = strchr(name, '\n');
+		if (ln)
+			*ln = '\0';
+	}
+
+	ret = sscanf(buf, "%d", &channel);
+	if (ret < 1)
+		return -EINVAL;
+
+	if (priv->leds[channel])
+		return -EBUSY;
+
+	if (channel > ET6326_MAX_LED_NUM - 1 || channel < 0)
+		return -EINVAL;
+
+	ret = create_led(priv, channel, name);
+	if (ret < 0)
+		return ret;
+
+	return len;
+}
+
+static ssize_t et6326_unexport_store(struct device *dev, struct device_attribute *attr,
+			  const char *buf, size_t len)
+{
+	struct et6326_leds_priv *priv = i2c_get_clientdata(to_i2c_client(dev));
+	u32 channel;
+	int ret;
+
+	ret = sscanf(buf, "%u", &channel);
+	if (ret < 1)
+		return -EINVAL;
+
+	ret = remove_led(priv, channel);
+	if (ret)
+		return ret;
+
+	return len;
+}
+
+static DEVICE_ATTR(export, S_IWUSR, NULL, et6326_export_store);
+static DEVICE_ATTR(unexport, S_IWUSR, NULL, et6326_unexport_store);
+
+#ifdef CONFIG_OF
+static void of_create_leds(struct et6326_leds_priv *priv, struct device *dev)
+{
+	struct device_node *child;
+
+	for_each_child_of_node(dev->of_node, child) {
+		const char *name;
+		u32 channel;
+
+		if (of_property_read_u32(child, "channel", &channel)) {
+			dev_err(dev, "%s: invalid channel\n", child->name);
+			continue;
+		}
+
+		of_property_read_string(child, "label", &name);
+
+		create_led(priv, channel, name);
+	}
+}
+#endif
+
+static int et6326_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct et6326_leds_priv *priv;	
+	int ret;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_NOSTART)) {
+		dev_err(&client->dev,
+			"need i2c bus that supports protocol mangling\n");
+		return -ENODEV;
+	}
+
+	priv = devm_kzalloc(dev, sizeof(struct et6326_leds_priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->client = client;
+	i2c_set_clientdata(client, priv);
+
+	/* Detect ET6326GU */
+	ret = et6326_write_byte(client, ET6326_REG_STATUS, 0x1f);
+	if (ret < 0) {
+		dev_err(dev, "failed to detect device\n");
+		return ret;
+	}
+
+	ret = device_create_file(dev, &dev_attr_export);
+	if (ret)
+		goto err_attr_export;
+
+	ret = device_create_file(dev, &dev_attr_unexport);
+	if (ret)
+		goto err_attr_unexport;
+
+#ifdef CONFIG_OF
+	of_create_leds(priv, dev);
+#endif
+
+	return 0;
+
+err_attr_unexport:
+	device_remove_file(&client->dev, &dev_attr_export);
+err_attr_export:
+	return ret;
+}
+
+static int et6326_remove(struct i2c_client *client)
+{
+	struct et6326_leds_priv *priv = i2c_get_clientdata(client);
+	int i;
+
+	for (i = 0; i < ET6326_MAX_LED_NUM; i++)
+		remove_led(priv, i);
+
+	et6326_write_byte(client, ET6326_REG_STATUS, 0x1f);
+
+	device_remove_file(&client->dev, &dev_attr_export);
+	device_remove_file(&client->dev, &dev_attr_unexport);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id of_et6326_match[] = {
+	{ .compatible = "etek,et6326" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, of_et6326_match);
+#endif
+
+static const struct i2c_device_id et6326_id[] = {
+	{ "et6326", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, et6326_id);
+
+static struct i2c_driver et6326_i2c_driver = {
+	.driver	= {
+		.name	= "et6326",
+		.of_match_table = of_match_ptr(of_et6326_match),
+	},
+	.probe		= et6326_probe,
+	.remove		= et6326_remove,
+	.id_table	= et6326_id,
+};
+
+module_i2c_driver(et6326_i2c_driver);
+
+MODULE_DESCRIPTION("ET6326 LED driver");
+MODULE_LICENSE("GPL v2");
diff --git a/target/linux/ramips/dts/GL-MT1300.dts b/target/linux/ramips/dts/GL-MT1300.dts
index 07f9b6986e..18dbb44ace 100755
--- a/target/linux/ramips/dts/GL-MT1300.dts
+++ b/target/linux/ramips/dts/GL-MT1300.dts
@@ -9,6 +9,13 @@
 	compatible = "glinet,gl-mt1300", "mediatek,mt7621-soc";
 	model = "GL-MT1300";
 
+	aliases {
+		led-boot = &led_run;
+		led-failsafe = &led_run;
+		led-running = &led_run;
+		led-upgrade = &led_run;
+	};
+
 	gl_hw {
 		compatible = "gl-hw-info";
 
@@ -33,12 +40,6 @@
 		bootargs = "console=ttyS0,115200";
 	};
 
-	palmbus: palmbus@1E000000 {
-		i2c@900 {
-			status = "okay";
-		};
-	};
-
 	keys {
 		compatible = "gpio-keys-polled";
 		poll-interval = <20>;
@@ -56,17 +57,27 @@
 		};
 	};
 
-	leds {
-		compatible = "gpio-leds";
+	i2c-gpio {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		compatible = "i2c-gpio";
+		gpios = <&gpio0 3 GPIO_ACTIVE_HIGH &gpio0 4 GPIO_ACTIVE_HIGH>;
+		i2c-gpio,delay-us = <10>;
 
-		led_run: blue {
-			label = "gl-mt1300:blue";
-			gpios = <&gpio0 14 GPIO_ACTIVE_HIGH>;
-		};
-		
-		white {
-			label = "gl-mt1300:white";
-			gpios = <&gpio0 13 GPIO_ACTIVE_HIGH>;
+		leds@30 {
+			compatible = "etek,et6326";
+			reg = <0x30>;
+
+			led_run: led@0 {
+				channel = <0>;
+				label = "gl-mt1300:blue";
+			};
+
+			led@1 {
+				channel = <1>;
+				label = "gl-mt1300:white";
+			};
 		};
 	};
 };
@@ -146,7 +157,7 @@
 &pinctrl {
 	state_default: pinctrl0 {
 		gpio {
-			ralink,group = "wdt", "rgmii2", "jtag", "mdio";
+			ralink,group = "wdt", "rgmii2", "jtag", "mdio", "i2c";
 			ralink,function = "gpio";
 		};
 	};
diff --git a/target/linux/ramips/image/mt7621.mk b/target/linux/ramips/image/mt7621.mk
index 708a606b98..dfadd69f93 100644
--- a/target/linux/ramips/image/mt7621.mk
+++ b/target/linux/ramips/image/mt7621.mk
@@ -210,7 +210,7 @@ define Device/gl-mt1300
   DEVICE_TITLE := GL-iNet GL-MT1300
   DEVICE_PACKAGES := \
 	 kmod-ata-core kmod-ata-ahci kmod-mt76x2 kmod-mt7603 kmod-usb3 \
-	 kmod-usb-ledtrig-usbport wpad-basic
+	 kmod-usb-ledtrig-usbport wpad-basic kmod-i2c-gpio kmod-leds-et6326
   IMAGE/sysupgrade.bin := append-kernel | append-rootfs | pad-rootfs | append-gl-metadata | check-size $$$$(IMAGE_SIZE)
 endef
 TARGET_DEVICES += gl-mt1300
-- 
2.17.1

